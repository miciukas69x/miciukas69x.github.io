<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Building a Maze Solver: finding paths through logic and code.</title>
    <link href="/SSG/index.css" rel="stylesheet" />
    <link rel="icon" href="/SSG/images/miciukasfavicon.png" type="image/png" />
    <link rel="icon" type="image/png" sizes="any" href="SSG/static/images/miciukasfavicon.png"?v=2>
  </head>

  <body>
    <article><div><h1>Building a Maze Solver: finding paths through logic and code.</h1><p><a href="/SSG/">< Back Home</a></p><p><video width="600" controls autoplay muted loop>   <source src="/SSG/videos/maze-solver-showcase.mp4" type="video/mp4">   Your browser does not support the video tag. </video></p><blockquote>"I wanted to explore algorithms beyond the textbook, so I built a maze generator and a solver from scratch. It's walls, passages, and the quiet logic of search - part puzzle, part pathfinding, and all code."</blockquote><p><a href="https://github.com/miciukas69x/maze_solver">View on GitHub</a></p><h2>Introduction</h2><p>This project is a program that generates random mazes and then solves them step by step. I built it to practice recursion, breadth-first search, depth-first search, and handling both logic and visuals at the same time. Itâ€™s where algorithms stop being abstract and start drawing paths you can see.</p><h2>Core Features</h2><ul><li>Maze generation: random walls, unique entrance and exit.</li><li>Pathfinding: implemented DFS and BFS(not yet) to navigate the maze.</li><li>Visualization: shows the maze and the solving process in real time.</li><li>Backtracking: highlights explored dead ends with different colors.</li><li>Unit tests: seperated pure logic from drawing so the algorithms can be tested cleanly.</li></ul><h2>What I Learned</h2><ul><li>Applied the theory (DFS, BFS) I've learned taking the DSA course. </li><li>How to combine recursion and state tracking without getting lost.</li><li>Why separating logic from rendering makes testing and debugging easier.</li><li>How small algorithms can come alive visually with just a few drawing calls.</li></ul><h2>Conclusion</h2><p>This project showed me that algorithms aren't just abstract puzzles - they can literally carve paths. Building the maze solver gave me hands-on experience with recursion, search strategies and visualization, while proving that algorithms practice can also be interactive and fun.</p></div></article>
  </body>
</html>
